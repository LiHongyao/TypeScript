# 一、概述

`TypeScript` 定义变量类型的语法格式：


```javascript
let 变量名：变量类型 = 值;
```

# 二、基本数据类型

```typescript
let str: string = 'Li-HONGYAO';
let num: number = 1;
let bool: boolean = true;
let sym: symbol = Symbol();
let big: bigint = 1n;
let nu: null = null;
let un: undefined = undefined;
```

需要注意：

- `null` 和 `undefined` 两个类型一旦赋值上，就不能在赋值给任何其他类型；
- `symbol` 是独一无二的，即 *`sym1 !== sym2`*

# 三、引用类型

## 1. Array

两种方式定义：

- `类型名称 + []`
- `Array<数据类型>`

```typescript
let arr1: number[] = [1, 2, 3];
let arr3: Array<number> = [1, 2, 3];

let arr2: (string | number)[] = [1, 'A', 2];
```

## 2. Tuple

元组类型允许表示一个 **已知元素数量和类型** 的数组，各元素的类型不必相同：

```typescript
let foo: [string, number];

foo = ['Li-HONGYAO', 30];
foo = [18, 'Li-HONGYAO']; // Type eror...
```

 解构元祖：

```typescript
let [uname, age] = ["Li-HONGYAO", 18];
console.log(uname); // Li-HONGYAO
console.log(age); // 18 
```

## 3. Object

1）`object` 非原始类型，在定义上直接使用 object 是可以的，但你要更改对象的属性就会报错，原因是并没有使对象的内部具体的属性做限制，所以需要使用 **{}** 来定义内部类型

```typescript
let o1: object = { a: 1, b: 2 };
o1.a = 3; // Property 'a' does not exist on type 'object'.

let o2: { a: number, b: number } = { a: 1, b: 2 };
o2.a = 3; // ok
```

2）`Object`(大写的O），代表所有的原始类型或非原始类型都可以进行赋值，除了`null`和`undefined`

```typescript
let o: Object;
o = 1;
o = 'ChengDu';
o = true;
o = {};
o = Symbol();
o = null; // Type 'null' is not assignable to type 'Object'.
o = undefined; // Type 'undefined' is not assignable to type 'Object'.
```

## 4. Function

**1）定义函数**

- 有两种方式：`function` / `arrow function`
- 在书写的时候，也可以写入返回值的类型，如果写入，则必须要有对应类型的返回值。**但通常情况下是省略**，因为`TS`的类型推断功能够正确推断出返回值类型

```typescript
function sayHello(name: string) {
    console.log(`Hello, ${name}!`);
}
sayHello('Li-HONGYAO');


const sayHi = (name: string) => console.log(`Hi, ${name}!`);
sayHi('Li-HONGYAO');
```

**2）参数类型**

- 可选参数：`?`
- 默认参数：`=`
- 剩余参数：`...`

```typescript
// -- 可选参数
function info(name: string, job?: string) {
    console.log(`${name} - ${job}`)
}
info('Li-HONGYAO'); // Li-HONGYAO - undefined"
info('Li-HONGYAO', '程序猿'); // Li-HONGYAO - 程序猿

// -- 默认参数
function user(name: string, gender: string = '保密') {
    console.log(`${name} - ${gender}`)
}
user('Tom'); // Tom - 保密
user('Tom', '男'); // Tom - 男

// -- 剩余参数
function sum(...nums: number[]) {
    const r = nums.reduce((prev, cur) => prev + cur, 0);
    console.log(r);
}
sum(1, 2, 3); // 6
```

**3）函数重载**

函数重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。在 `TypeScript` 中，表现为给同一个函数提供多个函数类型定义。简单的说：**可以在同一个函数下定义多种类型值，然后汇总到一块**

关于函数重载，必须要把精确的定义放在前面，最后函数实现时，需要使用 `|`操作符或者`?`操作符，把所有可能的输入类型全部包含进去：

```typescript
function reverse(message: string): string;
function reverse(message: string[]): string;
function reverse(message: string | string[]): string {
    if (typeof message === "string") {
        return message.split("").reverse().join("");
    } else {
        return message.reverse().join("");
    }
}
console.log(reverse("ABC")) // CBA
console.log(reverse(["A", "B", "C"])) // CBA
```

# 四、特殊类型

## 1. any

在 TS 中，`any` 用来表示任意类型。

```typescript
let msg: any;
msg = 'Hello, TS!';
msg = 123;
msg = false; 
msg.split(''); // 控制台输出：msg.split is not a function 
```

> 提示：
>
> - **变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型**，一般用于获取DOM。
> - `any` 是 TypeScript 中的顶级类型，使用 `any`，基本上放弃了类型检查，因此开发中会引起不必要的麻烦。比如上述示例中，访问 `split` 方法抛出异常。所以，一般情况下不建议使用 `any` 类型。

## 2. unknown

`unknown` 是TypeScript 3.0 中引入的，也被认为是顶级类型，但它更安全（严格），主要严格于以下两点：

- `unknow`会对值进行检测，而类型`any`不会做检测操作，说白了，`any`类型可以赋值给任何类型，但`unknow`只能赋值给`unknow`类型和`any`类型；
- `unknow`不允许定义的值有任何操作（如 方法，`new` 等），但 `any` 可以

```typescript
let msg: unknown;
msg = 'Hello, TS!';
msg = 123;
msg = false; 
msg.split(''); // TS语法检测：Object is of type 'unknown'.
```

可以发现，在使用 `any` 定义类型时，调用 `split` 方法并不会触发TS的语法检测，而使用 `unknown` 时，TS会捕捉到问题并予以提示。

## 3. void

当一个函数，没有返回值时，TS会默认他的返回值为 `void` 类型

```javascript
function run(): void {
    console.log("I'm running!");
}
```

声明一个 `void` 类型的变量没有什么大用，因为你只能为它赋予 `undefined` 和 `null`

## 4. never

`never` 类型表示的是永不存在的值的类型，那么与 `void` 相比, `never`应该是 `void`子集， 因为 `void`实际上的返回值为 `undefined`，而 `never` 连 `undefined`也不行。

符合`never`的情况有：当抛出异常的情况和无限死循环

```typescript
let error1 = () => {
    throw new Error('wrong!')
};

let error2 = () => {
    while (true) { }
}
```

## 5. Enum

可以定义一些带名字的常量，这样可以 **清晰表达意图** 或 **创建一组有区别的用例**。注意：

- 枚举的类型只能是 `string` 或 `number`

- 定义的名称不能为**关键字**

**1）数字枚举**

- 枚举的类型默认为 **数值类型**，从 `0` 开始累加，如果有设置默认值，则**只会对后面的值产生影响**
- 同时支持**反向映射**（及从成员值到成员名的映射），但智能映射无默认值的情况，并且只能是默认值的前面

```typescript
enum NumberType { A, B, C = 7, D };

console.log(NumberType.A);  // 正向映射 0
console.log(NumberType[0]); // 反向映射 A 
console.log(NumberType.C);  // 7
console.log(NumberType.D);  // 8
```

**2）字符串枚举**

字符串枚举要注意的是必须要有**默认值**，不支持**反向映射**

```typescript
enum ErrorType {
    NO_PARAMS = "参数缺失",
    NOT_DEFINED = "未定义",
    NOT_FOUNDE = "未找到"
}
```

**3）常量枚举**

除了`数字类型`和`字符串类型`之外，还有一种特殊的类型，那就是**常量枚组**，也就是通过`const`去定义`enum`，但这种类型不会编译成任何 `JS`,只会编译对应的值

```typescript
const enum NumberType { A, B, C, D };
let num1 = NumberType.A;
let num2 = NumberType.B;
console.log(num1);
console.log(num2);
```

**4）异构枚举**

包含了 `数字类型` 和 `字符串类型` 的混合，反向映射一样的道理。

```typescript
enum DataType { A, B, C = "C", D = 7, E };
```



# 四、联合类型

联合类型表示可以为变量定义多个类型，比如：

```typescript
let age: number | string;
age = 10;
age = '10';
```

上述示例示例中，变量 `age` 被定义成联合类型，可以赋值 `number` 类型 或者 `string` 类型的值。

通常在使用 `age` 变量时，为了更安全的使用，我们可以通过如下方法判断其具体类型之后进行相应的操作。

# 五、类型断言

类型断言（Type Assertion）可以用来手动指定一个值的类型。语法形式如下：

- `<Value>Type `
- `Value as Tpe`

示例：

```typescript
let _name: unknown = "木子李";
let len: number = (_name as string).length;
let len: number = (<string>_name).length;
```

# 六、类型推断

如果没有明确的指定类型，那么 TypeScript 会推断出一个类型。

```typescript
let hello = "Hello, TypeScript!";
hello = 10; // Type 'number' is not assignable to type 'string'.
```

> 提示：如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 `any` 类型而完全不被类型检查。

# 七、类型别名

类型别名用来给一个类型起个新名字：

```typescript
// 为 string 类型定义别名 LString;
type LString = string;
// 定义变量，指定类型为 LString（实际为 string 类型）
let message: LString;

message = 'Are you ok?';
message = 10; // Type 'number' is not assignable to type 'string'.
```

类型别名对于一些联合类型或者复杂类型比较有用，可以使其更加简洁，比如：

```javascript
// 定义用户类型
type UserType = {
    name: string;
    age: number;
    job: string;
}
// 定义年龄类型
type AgeType = string | number;

let user: UserType = {
    name: "Li-HONGYAO",
    age: 18,
    job: '前端工程师'
}
let age: AgeType = user.age;
```

#  八、字面量类型

```typescript
type LoginType = "用户名" | "邮箱" | "手机号";
let _type: LoginType;
_type = "手机号";
_type = "邮箱";
_type = "用户名";
_type = "微信"; // Type '"微信"' is not assignable to type 'LoginType'.
```

上例中，我们使用 `type` 定了一个字符串字面量类型 _type，它只能取三种字符串中的一种。

> 注意，**类型别名与字符串字面量类型都是使用** `type` **进行定义。**



