# 一、概述

TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。

# 二、接口初探

下面通过一个简单示例来观察接口是如何工作的：

```typescript
function desc(stu: {name: string, age: number, major: string}) {
    console.log(`
        姓名：${stu.name},
        年龄：${stu.age},
        专业：${stu.major}
    `);
};
desc({
    name: "木子李",
    age: 29,
    major: "软件技术"
});
```

类型检查器会查看 desc 的调用。 desc 有一个参数，并要求这个对象参数有 `name`、`age`、`major`三个属性，且数据类型分别是 `string`、 `number`、 string`。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。

下面我们重写上面的例子，这次使用接口来描述：

```typescript
// 定义接口
interface Student {
    name: string,
    age: number,
    major: string
};

function desc(stu: Student) {
    console.log(`
        姓名：${stu.name},
        年龄：${stu.age},
        专业：${stu.major}
    `);
};
desc({
    name: "木子李",
    age: 29,
    major: "软件技术"
});
```

# 三、可选属性

接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。

下面是应用了“option bags”的例子：

```typescript
interface SquareConfig {
  color?: string; // => 方块颜色
  width?: number; // => 方块宽度
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: "white", area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({color: "black"});
```

带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个`?`符号。

可选属性的好处主要有一下两点：

- 可以对可能存在的属性进行预定义。
- 可以捕获引用了不存在的属性时的错误。

比如，我们故意将`createSquare`里的`color`属性名拼错，就会得到一个错误提示：

```typescript
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): { color: string; area: number } {
  let newSquare = {color: "white", area: 100};
  if (config.color) {
    // Error: Property 'clor' does not exist on type 'SquareConfig'
    newSquare.color = config.clor;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({color: "black"});
```


# 四、只读属性

```typescript
interface Point {
    readonly x: number;
    readonly y: number;
}
```

TypeScript具有`ReadonlyArray`类型，它与`Array`相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：

```typescript
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!
```

上面代码的最后一行，可以看到就算把整个`ReadonlyArray`赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：

```typescript
a = ro as number[];
```

**readonly VS const**

最简单判断该用`readonly`还是`const`的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用`const`，若做为属性则使用`readonly`。

# 五、绕过额外的属性检查

- 通过 `as` 实现
- 将传递数据赋值给另一个变量
- 字符串索引签名：`[propName: string]: any;`

# 六、函数类型

```typescript
// 定义接口
interface SumFunc {
    // 函数类型：参数列表+返回值类型组成
    (a: number, b: number):number;
}
// 使用接口
let sumA: SumFunc = (a: number, b: number): number => {
    return a + b;
}
let sumB: SumFunc = (a, b) => {
    return a + b;
}

let sumC: SumFunc = (m, n) => {
    return m + n;                   
}
console.log(sumA(10, 5));
console.log(sumB(10, 5));
console.log(sumC(10, 5))、
```

# 七、可索引类型

可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。

```typescript
// 1. 数字索引
interface NumIndexes {
    [index: number]: string;
}

let fruits: NumIndexes = ["苹果", "香蕉", "西瓜", "橘子"];
let fruit: string = fruits[1];
console.log(fruit);

// 2. 字符串索引
interface StrIndexes {
    [key: string]: string;
  	name: string; // 可以，name是string类型
    age: number; // 错误，age的类型与索引类型返回值的类型不匹配
}
// 3. 只读索引
interface ReadOnlyIndexes {
    readonly [index: number]: number;
}
let nums: ReadOnlyIndexes = [1, 2, 3];
nums[0] = 8; // err => 类型“ReadOnlyIndexes”中的索引签名仅允许读取
```

# 八、类类型

## 1、实现接口

```typescript
interface _Person {
    // 定义属性
    name: string;
    age: number;
    // 定义方法
    description(): void;
}
class Person implements _Person {
    name: string;
    age: number;
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
    description() {
        console.log(`大家好，我叫${this.name}，今年${this.age}岁，很高见到各位！`);
    }
}

let per = new Person("木子李", 30);
per.description();
// => 大家好，我叫木子李，今年30岁，很高见到各位！
```

> 提示：接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。

## 2. 静态部分与实例部分的区别

当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：

```js
interface _PersonConstructor {
    new (name: string, age: number);
}
class Person implements _PersonConstructor {
    constructor(name: string, age: number) {   }
}
```

这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。

因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， *_PersonConstructor* 为构造函数所用和 *_Person* 为实例方法所用。 为了方便我们定义一个构造函数 *createPerson* ，它用传入的类型创建实例。

```typescript
// 构造函数接口
interface _PersonConstructor {
    new (name: string, age: number): _Person;
}
// 实例接口
interface _Person {
    sayHello(): void;
}


function createPerson(_PersonConstructor: _PersonConstructor, name: string, age: number): _Person {
    return new _PersonConstructor(name, age);
}

class Teacher implements _Person {
    sayHello() {
        console.log("Hello!");
    }
}

class Student implements _Person {
    sayHello() {
        console.log("Hi!");
    }
}
let tea = createPerson(Teacher, "木子李", 29);
let stu = createPerson(Student, "王昭君", 30);
tea.sayHello();
stu.sayHello();
```

因为 *createPerson* 的第一个参数是 *_PersonConstructor* 类型，在 *createPerson(Teacher, "木子李", 29);* 里，会检查 *Teacher* 是否符合构造函数签名。

# 九、接口继承

和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。

```typescript
interface Size {
    width: number;
    height: number;
}
interface View extends Size {
    background: string;
} 
let view: View = {
    width: 100,
    height: 100,
    background: "pink"
}
```

一个接口可以继承多个接口，创建出多个接口的合成接口。

```typescript
interface Size {
    width: number;
    height: number;
}
interface Point {
    x: number;
    y: number;
}
interface View extends Size, Point {
    background: string;
} 
let view: View = {
    width: 100,
    height: 100,
    x: 0,
    y: 0,
    background: "pink"
}
```

# 十、混合类型

先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。

一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。


