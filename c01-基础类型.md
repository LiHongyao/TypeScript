通过Typescript 可以限制数据类型，Typescript 能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。

```js
let 变量名: 数据类型;
```

# 一、基本数据类型

```js
let isLogin: boolean; // 限制数据类型为布尔类型
let message: string; // 限制数据类型为字符串类型
let age: number; // 限制数据类型为数值类型
```

# 二、数组

在元素类型后面接上方括号`[]`，表示由此类型元素组成的一个数组：

```typescript
let list:number[] = [1, 2, 3, 4];
```

第二种方式是使用数组泛型，`Array<元素类型>`：

```typescript
let list:Array<number> = [1, 2, 3, 4];
```

# 三、元组

```typescript
let infos: [string, number];
infos = ["木子李", 28]; // ok
infos = [28, "木子李"]; // typer error
```

当访问一个已知索引的元素，会得到正确的类型：

```typescript
infos[0].slice(0);
infos[1].slice(1); // Property 'slice' does not exist on type 'number'.
```

当访问一个越界的元素，会使用联合类型替代：

# 四、枚举

`enum` 类型是对JavaScript标准数据类型的一个补充。 像C等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。

```typescript
enum Color { Red, Green, Blue};
let color: Color = Color.Blue;
```

默认情况下，从`0`开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从`1`开始编号：

```typescript
enum Color {Red = 1, Green, Blue}
```

或者，全部都采用手动赋值：

```typescript
enum Color {Red = 1, Green = 2, Blue = 4}
```

枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：

```typescript
enum Color {Red = 1, Green = 2, Blue = 4}
let colorName: string = Color[2]; // Green
```

# 四、任意值

有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用`any`类型来标记这些变量：

```typescript
let arr:Array<any> = [1, "2", true];
```

# 五、 空值

某种程度上来说，`void`类型像是与`any`类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是`void`：

```typescript
function sayHello(): void {
    alert("Hello!");
}
```

声明一个`void`类型的变量没有什么大用，因为你只能为它赋予`undefined`和`null`：

```typescript
let unusable: void = undefined;
```

# 六、类型断言

类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 比如后台返回一个数据为字符串类型，但你确信这应该是一个数值类型，那你可以通过 `as` 关键字进行类型断言。

```typescript
let message: any = "Hello, china!";
message as string; // <string>message 等价
```

# 七、类型推断

类型推断即类型是在哪里如何被推断的。TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子

```typescript
let x = 10;
x = "10"; // => 不能将类型“"10"”分配给类型“number”。
```

变量`x`的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。大多数情况下，类型推论是直截了当地。 后面的小节，我们会浏览类型推论时的细微差别。

## 1. 最佳通用类型

当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。例如：

```typescript
let x = [0, 1, null]; // => （number | null）[]
```

为了推断`x`的类型，我们必须考虑所有元素的类型。 这里有两种选择： `number`和`null`。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。

由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。例如：

```typescript
let zoo = [new Rhino(), new Elephant(), new Snake()];
```

这里，我们想让zoo被推断为`Animal[]`类型，但是这个数组里没有对象是`Animal`类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：

```typescript
let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];
```

如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，`(Rhino | Elephant | Snake)[]`。

## 2. 上下文类型

TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。比如：

```
window.onmousedown = function(mouseEvent) {
    console.log(mouseEvent.button);  //<- Error
};
```

这个例子会得到一个类型错误，TypeScript类型检查器使用`Window.onmousedown`函数的类型来推断右边函数表达式的类型。 因此，就能推断出 `mouseEvent`参数的类型了。 如果函数表达式不是在上下文类型的位置， `mouseEvent`参数的类型需要指定为`any`，这样也不会报错了。

如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。 重写上面的例子：

```typescript
window.onmousedown = function(mouseEvent: any) {
    console.log(mouseEvent.button);  //<- Now, no error is given
};
```

这个函数表达式有明确的参数类型注解，上下文类型被忽略。 这样的话就不报错了，因为这里不会使用到上下文类型。

上下文归类会在很多情况下使用到。 通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。 上下文类型也会做为最佳通用类型的候选类型。比如：

```type
function createZoo(): Animal[] {
    return [new Rhino(), new Elephant(), new Snake()];
}
```

这个例子里，最佳通用类型有4个候选者：`Animal`，`Rhino`，`Elephant`和`Snake`。 当然， `Animal`会被做为最佳通用类型。